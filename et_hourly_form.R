E_day_to_hour <- function(ep,date,Lat,Long){
  
  #--------------- Format warnings ----------------------
  if(!class(ep) == "numeric") stop("ep is not numeric.")
  
  if(class(date) == "character") {
    date = lubridate::ymd(date)
    attributes(date)$tzone <- Sys.timezone()
    if(is.na(date)){
      warning("Date is of non-readable format")
    }else{
      warning("Date has no timezone, system timezone is assumed.")
    }
  } else if(!class(date) == "Date" & !class(date) == "POSIXct") stop("Date is of unknown format.")
  
  if(!class(Lat) == "numeric") stop("Lat is not numeric.")
  if(!class(Long) == "numeric") stop("Long is not numeric.")
  
  #----------------- Sunset - sunrise calculator ----------------------------
  suncalc<-function(d,Lat,Long){
    ## d is the day of year
    ## Lat is latitude in decimal degrees
    ## Long is longitude in decimal degrees (negative == West)
    
    ##This method is copied from:
    ##Teets, D.A. 2003. Predicting sunrise and sunset times.
    ##  The College Mathematics Journal 34(4):317-321.
    
    ## At the default location the estimates of sunrise and sunset are within
    ## seven minutes of the correct times (http://aa.usno.navy.mil/data/docs/RS_OneYear.php)
    ## with a mean of 2.4 minutes error.
    
    ## Function to convert degrees to radians
    rad<-function(x)pi*x/180
    
    ##Radius of the earth (km)
    R=6378
    
    ##Radians between the xy-plane and the ecliptic plane
    epsilon=rad(23.45)
    
    ##Convert observer's latitude to radians
    L=rad(Lat)
    
    ## Calculate offset of sunrise based on longitude (min)
    ## If Long is negative, then the mod represents degrees West of
    ## a standard time meridian, so timing of sunrise and sunset should
    ## be made later.
    timezone = -4*(abs(Long)%%15)*sign(Long)
    
    ## The earth's mean distance from the sun (km)
    r = 149598000
    
    theta = 2*pi/365.25*(d-80)
    
    z.s = r*sin(theta)*sin(epsilon)
    r.p = sqrt(r^2-z.s^2)
    
    t0 = 1440/(2*pi)*acos((R-z.s*sin(L))/(r.p*cos(L)))
    
    ##a kludge adjustment for the radius of the sun
    that = t0+5 
    
    ## Adjust "noon" for the fact that the earth's orbit is not circular:
    n = 720-10*sin(4*pi*(d-80)/365.25)+8*sin(2*pi*d/365.25)
    
    ## now sunrise and sunset are:
    sunrise = (n-that+timezone)/60
    sunset = (n+that+timezone)/60
    
    return(list("sunrise" = sunrise,"sunset" = sunset))
  }
  
  #get day of the year
  day = strptime(date, "%Y-%m-%d")$yday+1
  date = as.POSIXct(date)
  #get moment of sunrise and sunset in UTC timezone
  sunlist = suncalc(day,Lat,Long)
  rise = sunlist$sunrise
  set = sunlist$sunset
  
  #get timezone
  timezone = lubridate::tz(date)
  #sunset and sunrise are in UTC timezone
  date.utc = date
  attributes(date.utc)$tzone <- "UTC"
  date.utc = as.POSIXct(as.character(date.utc), tz = timezone)
  #hour difference between UTC and used timezone
  tdif = as.numeric(date.utc-date)
  #correct for timezone
  rise = rise - tdif
  set = set - tdif
  
  #-------------- Downscaling evaporation (see T. de Boer-Euser, 2017) ----------------------
  #Hour vector
  x = (1:24)
  #Downscaling parameters
  dl = set - rise + 1
  g = 2*pi/(2*dl)
  h = dl - 12
  a = -ep*g/(sin(g*(set+h))-sin(g*(rise+h)))
  eph = -a*(cos(g*(x+h)))
  eph[x < rise | x > set] = 0
  
  #result
  return(eph)
}
